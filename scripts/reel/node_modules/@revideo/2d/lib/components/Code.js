var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { BBox, createSignal, experimentalLog, map, unwrap, useLogger, useScene, } from '@revideo/core';
import { CodeCursor, codeSignal, CodeSignalContext, findAllCodeRanges, isPointInCodeSelection, lines, parseCodeSelection, resolveScope, } from '../code';
import { computed, initial, nodeName, parser, signal } from '../decorators';
import { Shape } from './Shape';
/**
 * A node for displaying and animating code.
 *
 * @experimental
 *
 * @preview
 * ```tsx editor
 * import {parser} from '@lezer/javascript';
 * import {Code, LezerHighlighter, makeScene2D} from '@revideo/2d';
 * import {createRef} from '@revideo/core';
 *
 * export default makeScene2D(function* (view) {
 *   LezerHighlighter.registerParser(parser);
 *   const code = createRef<Code>();
 *
 *   view.add(
 *     <Code
 *       ref={code}
 *       offset={-1}
 *       position={view.size().scale(-0.5).add(60)}
 *       fontFamily={'JetBrains Mono, monospace'}
 *       fontSize={36}
 *       code={`\
 * function hello() {
 *   console.log('Hello');
 * }`}
 *     />,
 *   );
 *
 *   yield* code()
 *     .code(
 *       `\
 * function hello() {
 *   console.warn('Hello World');
 * }`,
 *       1,
 *     )
 *     .wait(0.5)
 *     .back(1)
 *     .wait(0.5);
 * });
 * ```
 */
let Code = class Code extends Shape {
    /**
     * Create a standalone code signal.
     *
     * @param initial - The initial code.
     * @param highlighter - Custom highlighter to use.
     */
    static createSignal(initial, highlighter) {
        return new CodeSignalContext(initial, undefined, highlighter).toSignal();
    }
    setDrawHooks(value) {
        if (!useScene().experimentalFeatures &&
            value !== this.drawHooks.context.getInitial()) {
            useLogger().log({
                ...experimentalLog(`Code uses experimental draw hooks.`),
                inspect: this.key,
            });
        }
        else {
            this.drawHooks.context.setter(value);
        }
    }
    *tweenSelection(value, duration, timingFunction) {
        this.oldSelection = this.selection();
        this.selection(value);
        this.selectionProgress(0);
        yield* this.selectionProgress(1, duration, timingFunction);
        this.selectionProgress(null);
        this.oldSelection = null;
    }
    /**
     * Get the currently displayed code as a string.
     */
    parsed() {
        return resolveScope(this.code(), scope => unwrap(scope.progress) > 0.5);
    }
    highlighterCache() {
        const highlighter = this.highlighter();
        if (!highlighter || !highlighter.initialize())
            return null;
        const code = this.code();
        const before = resolveScope(code, false);
        const after = resolveScope(code, true);
        return {
            before: highlighter.prepare(before),
            after: highlighter.prepare(after),
        };
    }
    get cursor() {
        this.cursorCache ?? (this.cursorCache = new CodeCursor(this));
        return this.cursorCache;
    }
    constructor(props) {
        super({
            fontFamily: 'monospace',
            ...props,
        });
        this.oldSelection = null;
        this.selectionProgress = createSignal(null);
    }
    /**
     * Create a child code signal.
     *
     * @param initial - The initial code.
     */
    createSignal(initial) {
        return new CodeSignalContext(initial, this, this.highlighter).toSignal();
    }
    /**
     * Find all code ranges that match the given pattern.
     *
     * @param pattern - Either a string or a regular expression to match.
     */
    findAllRanges(pattern) {
        return findAllCodeRanges(this.parsed(), pattern);
    }
    /**
     * Find the first code range that matches the given pattern.
     *
     * @param pattern - Either a string or a regular expression to match.
     */
    findFirstRange(pattern) {
        return (findAllCodeRanges(this.parsed(), pattern, 1)[0] ?? [
            [0, 0],
            [0, 0],
        ]);
    }
    /**
     * Find the last code range that matches the given pattern.
     *
     * @param pattern - Either a string or a regular expression to match.
     */
    findLastRange(pattern) {
        return (findAllCodeRanges(this.parsed(), pattern).at(-1) ?? [
            [0, 0],
            [0, 0],
        ]);
    }
    /**
     * Return the bounding box of the given point (character) in the code.
     *
     * @remarks
     * The returned bound box is in local space of the `Code` node.
     *
     * @param point - The point to get the bounding box for.
     */
    getPointBbox(point) {
        const [line, column] = point;
        const drawingInfo = this.drawingInfo();
        let match;
        for (const info of drawingInfo.fragments) {
            if (info.cursor.y < line) {
                match = info;
                continue;
            }
            if (info.cursor.y === line && info.cursor.x < column) {
                match = info;
                continue;
            }
            break;
        }
        if (!match)
            return new BBox();
        const size = this.computedSize();
        return new BBox(match.position
            .sub(size.scale(0.5))
            .addX(match.characterSize.x * (column - match.cursor.x)), match.characterSize);
    }
    /**
     * Return bounding boxes of all characters in the selection.
     *
     * @remarks
     * The returned bound boxes are in local space of the `Code` node.
     * Each line of code has a separate bounding box.
     *
     * @param selection - The selection to get the bounding boxes for.
     */
    getSelectionBbox(selection) {
        const size = this.computedSize();
        const range = parseCodeSelection(selection);
        const drawingInfo = this.drawingInfo();
        const bboxes = [];
        let current = null;
        let line = 0;
        let column = 0;
        for (const info of drawingInfo.fragments) {
            if (info.cursor.y !== line) {
                line = info.cursor.y;
                if (current) {
                    bboxes.push(current);
                    current = null;
                }
            }
            column = info.cursor.x;
            for (let i = 0; i < info.text.length; i++) {
                if (isPointInCodeSelection([line, column], range)) {
                    const bbox = new BBox(info.position
                        .sub(size.scale(0.5))
                        .addX(info.characterSize.x * (column - info.cursor.x)), info.characterSize);
                    if (!current) {
                        current = bbox;
                    }
                    else {
                        current = current.union(bbox);
                    }
                }
                else if (current) {
                    bboxes.push(current);
                    current = null;
                }
                column++;
            }
        }
        if (current) {
            bboxes.push(current);
        }
        return bboxes;
    }
    drawingInfo() {
        this.requestFontUpdate();
        const context = this.cacheCanvas();
        const code = this.code();
        context.save();
        this.applyStyle(context);
        this.applyText(context);
        this.cursor.setupDraw(context);
        this.cursor.drawScope(code);
        const info = this.cursor.getDrawingInfo();
        context.restore();
        return info;
    }
    desiredSize() {
        this.requestFontUpdate();
        const context = this.cacheCanvas();
        const code = this.code();
        context.save();
        this.applyStyle(context);
        this.applyText(context);
        this.cursor.setupMeasure(context);
        this.cursor.measureSize(code);
        const size = this.cursor.getSize();
        context.restore();
        return size;
    }
    async draw(context) {
        this.requestFontUpdate();
        this.applyStyle(context);
        this.applyText(context);
        const size = this.computedSize();
        const drawingInfo = this.drawingInfo();
        context.save();
        context.translate(-size.width / 2, -size.height / 2 + drawingInfo.verticalOffset);
        const drawHooks = this.drawHooks();
        for (const info of drawingInfo.fragments) {
            context.save();
            context.globalAlpha *= info.alpha;
            drawHooks.token(context, info.text, info.position, info.fill, info.time);
            context.restore();
        }
        context.restore();
        await this.drawChildren(context);
    }
    applyText(context) {
        super.applyText(context);
        context.font = this.styles.font;
        context.textBaseline = 'top';
        if ('letterSpacing' in context) {
            context.letterSpacing = this.styles.letterSpacing;
        }
    }
    collectAsyncResources() {
        super.collectAsyncResources();
        this.highlighter()?.initialize();
    }
};
Code.defaultHighlighter = null;
__decorate([
    initial(() => Code.defaultHighlighter),
    signal()
], Code.prototype, "highlighter", void 0);
__decorate([
    codeSignal()
], Code.prototype, "code", void 0);
__decorate([
    initial({
        token(ctx, text, position, color, selection) {
            ctx.fillStyle = color;
            ctx.globalAlpha *= map(0.2, 1, selection);
            ctx.fillText(text, position.x, position.y);
        },
    }),
    signal()
], Code.prototype, "drawHooks", void 0);
__decorate([
    initial(lines(0, Infinity)),
    parser(parseCodeSelection),
    signal()
], Code.prototype, "selection", void 0);
__decorate([
    computed()
], Code.prototype, "parsed", null);
__decorate([
    computed()
], Code.prototype, "highlighterCache", null);
__decorate([
    computed()
], Code.prototype, "drawingInfo", null);
Code = __decorate([
    nodeName('CodeBlock')
], Code);
export { Code };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ29kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9Db2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQVNBLE9BQU8sRUFDTCxJQUFJLEVBQ0osWUFBWSxFQUNaLGVBQWUsRUFDZixHQUFHLEVBQ0gsTUFBTSxFQUNOLFNBQVMsRUFDVCxRQUFRLEdBQ1QsTUFBTSxlQUFlLENBQUM7QUFXdkIsT0FBTyxFQUNMLFVBQVUsRUFDVixVQUFVLEVBQ1YsaUJBQWlCLEVBQ2pCLGlCQUFpQixFQUNqQixzQkFBc0IsRUFDdEIsS0FBSyxFQUNMLGtCQUFrQixFQUNsQixZQUFZLEdBQ2IsTUFBTSxTQUFTLENBQUM7QUFDakIsT0FBTyxFQUFDLFFBQVEsRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFHMUUsT0FBTyxFQUFDLEtBQUssRUFBQyxNQUFNLFNBQVMsQ0FBQztBQXFEOUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTBDRztBQUVJLElBQU0sSUFBSSxHQUFWLE1BQU0sSUFBSyxTQUFRLEtBQUs7SUFDN0I7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsWUFBWSxDQUN4QixPQUEwQixFQUMxQixXQUEwQztRQUUxQyxPQUFPLElBQUksaUJBQWlCLENBQzFCLE9BQU8sRUFDUCxTQUFTLEVBQ1QsV0FBVyxDQUNaLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDZixDQUFDO0lBd0RTLFlBQVksQ0FBQyxLQUFnQjtRQUNyQyxJQUNFLENBQUMsUUFBUSxFQUFFLENBQUMsb0JBQW9CO1lBQ2hDLEtBQUssS0FBSyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsRUFDN0MsQ0FBQztZQUNELFNBQVMsRUFBRSxDQUFDLEdBQUcsQ0FBQztnQkFDZCxHQUFHLGVBQWUsQ0FBQyxvQ0FBb0MsQ0FBQztn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