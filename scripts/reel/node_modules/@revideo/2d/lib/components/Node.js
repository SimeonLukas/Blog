var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Node_1;
import { BBox, DependencyContext, UNIFORM_DESTINATION_MATRIX, UNIFORM_SOURCE_MATRIX, UNIFORM_TIME, Vector2, all, clamp, createSignal, easeInOutCubic, isReactive, modify, threadable, transformAngle, transformScalar, transformVector, transformVectorAsPoint, unwrap, useLogger, } from '@revideo/core';
import { cloneable, colorSignal, computed, getPropertiesOf, initial, initializeSignals, inspectable, nodeName, parser, signal, vector2Signal, wrapper, } from '../decorators';
import { filtersSignal } from '../decorators/filtersSignal';
import { spacingSignal } from '../decorators/spacingSignal';
import { parseShader } from '../partials/ShaderConfig';
import { useScene2D } from '../scenes/useScene2D';
import { drawLine } from '../utils';
let Node = Node_1 = class Node {
    get x() {
        return this.position.x;
    }
    get y() {
        return this.position.y;
    }
    getAbsolutePosition() {
        const matrix = this.localToWorld();
        return new Vector2(matrix.m41, matrix.m42);
    }
    setAbsolutePosition(value) {
        this.position(modify(value, unwrapped => transformVectorAsPoint(new Vector2(unwrapped), this.worldToParent())));
    }
    getAbsoluteRotation() {
        const matrix = this.localToWorld();
        return Vector2.degrees(matrix.m11, matrix.m12);
    }
    setAbsoluteRotation(value) {
        this.rotation(modify(value, unwrapped => transformAngle(unwrapped, this.worldToParent())));
    }
    getAbsoluteScale() {
        const matrix = this.localToWorld();
        return new Vector2(Vector2.magnitude(matrix.m11, matrix.m12), Vector2.magnitude(matrix.m21, matrix.m22));
    }
    setAbsoluteScale(value) {
        this.scale(modify(value, unwrapped => this.getRelativeScale(new Vector2(unwrapped))));
    }
    getRelativeScale(scale) {
        const parentScale = this.parent()?.absoluteScale() ?? Vector2.one;
        return scale.div(parentScale);
    }
    *tweenCompositeOperation(value, time, timingFunction) {
        const nextValue = unwrap(value);
        if (nextValue === 'source-over') {
            yield* this.compositeOverride(1, time, timingFunction);
            this.compositeOverride(0);
            this.compositeOperation(nextValue);
        }
        else {
            this.compositeOperation(nextValue);
            this.compositeOverride(1);
            yield* this.compositeOverride(0, time, timingFunction);
        }
    }
    absoluteOpacity() {
        return (this.parent()?.absoluteOpacity() ?? 1) * this.opacity();
    }
    hasFilters() {
        return !!this.filters().find(filter => filter.isActive());
    }
    hasShadow() {
        return (!!this.shadowColor() &&
            (this.shadowBlur() > 0 ||
                this.shadowOffset.x() !== 0 ||
                this.shadowOffset.y() !== 0));
    }
    filterString() {
        let filters = '';
        const matrix = this.compositeToWorld();
        for (const filter of this.filters()) {
            if (filter.isActive()) {
                filters += ' ' + filter.serialize(matrix);
            }
        }
        return filters;
    }
    getSpawner() {
        return this.children();
    }
    setSpawner(value) {
        this.children(value);
    }
    setChildren(value) {
        if (this.children.context.raw() === value) {
            return;
        }
        this.children.context.setter(value);
        if (!isReactive(value)) {
            this.spawnChildren(false, value);
        }
        else if (!this.hasSpawnedChildren) {
            for (const oldChild of this.realChildren) {
                oldChild.parent(null);
            }
        }
    }
    getChildren() {
        this.children.context.getter();
        return this.spawnedChildren();
    }
    spawnedChildren() {
        const children = this.children.context.getter();
        if (isReactive(this.children.context.raw())) {
            this.spawnChildren(true, children);
        }
        return this.realChildren;
    }
    sortedChildren() {
        return [...this.children()].sort((a, b) => Math.sign(a.zIndex() - b.zIndex()));
    }
    constructor({ children, spawner, key, ...rest }) {
        this.compositeOverride = createSignal(0);
        this.stateStack = [];
        this.realChildren = [];
        this.hasSpawnedChildren = false;
        this.parent = createSignal(null);
        this.properties = getPropertiesOf(this);
        const scene = useScene2D();
        [this.key, this.unregister] = scene.registerNode(this, key);
        this.view2D = scene.getView();
        this.creationStack = new Error().stack;
        initializeSignals(this, rest);
        if (spawner) {
            useLogger().warn({
                message: 'Node.spawner() has been deprecated.',
                remarks: 'Use <code>Node.children()</code> instead.',
                inspect: this.key,
                stack: new Error().stack,
            });
        }
        this.children(spawner ?? children);
    }
    /**
     * Get the local-to-world matrix for this node.
     *
     * @remarks
     * This matrix transforms vectors from local space of this node to world
     * space.
     *
     * @example
     * Calculate the absolute position of a point located 200 pixels to the right
     * of the node:
     * ```ts
     * const local = new Vector2(0, 200);
     * const world = transformVectorAsPoint(local, node.localToWorld());
     * ```
     */
    localToWorld() {
        const parent = this.parent();
        return parent
            ? parent.localToWorld().multiply(this.localToParent())
            : this.localToParent();
    }
    /**
     * Get the world-to-local matrix for this node.
     *
     * @remarks
     * This matrix transforms vectors from world space to local space of this
     * node.
     *
     * @example
     * Calculate the position relative to this node for a point located in the
     * top-left corner of the screen:
     * ```ts
     * const world = new Vector2(0, 0);
     * const local = transformVectorAsPoint(world, node.worldToLocal());
     * ```
     */
    worldToLocal() {
        return this.localToWorld().inverse();
    }
    /**
     * Get the world-to-parent matrix for this node.
     *
     * @remarks
     * This matrix transforms vectors from world space to local space of this
     * node's parent.
     */
    worldToParent() {
        return this.parent()?.worldToLocal() ?? new DOMMatrix();
    }
    /**
     * Get the local-to-parent matrix for this node.
     *
     * @remarks
     * This matrix transforms vectors from local space of this node to local space
     * of this node's parent.
     */
    localToParent() {
        const matrix = new DOMMatrix();
        matrix.translateSelf(this.x(), this.y());
        matrix.rotateSelf(0, 0, this.rotation());
        matrix.scaleSelf(this.scale.x(), this.scale.y());
        matrix.skewXSelf(this.skew.x());
        matrix.skewYSelf(this.skew.y());
        return matrix;
    }
    /**
     * A matrix mapping composite space to world space.
     *
     * @remarks
     * Certain effects such as blur and shadows ignore the current transformation.
     * This matrix can be used to transform their parameters so that the effect
     * appears relative to the closest composite root.
     */
    compositeToWorld() {
        return this.compositeRoot()?.localToWorld() ?? new DOMMatrix();
    }
    compositeRoot() {
        if (this.composite()) {
            return this;
        }
        return this.parent()?.compositeRoot() ?? null;
    }
    compositeToLocal() {
        const root = this.compositeRoot();
        if (root) {
            const worldToLocal = this.worldToLocal();
            worldToLocal.m44 = 1;
            return root.localToWorld().multiply(worldToLocal);
        }
        return new DOMMatrix();
    }
    view() {
        return this.view2D;
    }
    /**
     * Add the given node(s) as the children of this node.
     *
     * @remarks
     * The nodes will be appended at the end of the children list.
     *
     * @example
     * ```tsx
     * const node = <Layout />;
     * node.add(<Rect />);
     * node.add(<Circle />);
     * ```
     * Result:
     * ```mermaid
     * graph TD;
     *   layout([Layout])
     *   circle([Circle])
     *   rect([Rect])
     *     layout-->rect;
     *     layout-->circle;
     * ```
     *
     * @param node - A node or an array of nodes to append.
     */
    add(node) {
        return this.insert(node, Infinity);
    }
    /**
     * Insert the given node(s) at the specified index in the children list.
     *
     * @example
     * ```tsx
     * const node = (
     *   <Layout>
     *     <Rect />
     *     <Circle />
     *   </Layout>
     * );
     *
     * node.insert(<Txt />, 1);
     * ```
     *
     * Result:
     * ```mermaid
     * graph TD;
     *   layout([Layout])
     *   circle([Circle])
     *   text([Text])
     *   rect([Rect])
     *     layout-->rect;
     *     layout-->text;
     *     layout-->circle;
     * ```
     *
     * @param node - A node or an array of nodes to insert.
     * @param index - An index at which to insert the node(s).
     */
    insert(node, index = 0) {
        const array = Array.isArray(node) ? node : [node];
        if (array.length === 0) {
            return this;
        }
        const children = this.children();
        const newChildren = children.slice(0, index);
        for (const node of array) {
            if (node instanceof Node_1) {
                newChildren.push(node);
                node.remove();
                node.parent(this);
            }
        }
        newChildren.push(...children.slice(index));
        this.setParsedChildren(newChildren);
        return this;
    }
    /**
     * Remove this node from the tree.
     */
    remove() {
        const current = this.parent();
        if (current === null) {
            return this;
        }
        current.removeChild(this);
        this.parent(null);
        return this;
    }
    /**
     * Rearrange this node in relation to its siblings.
     *
     * @remarks
     * Children are rendered starting from the beginning of the children list.
     * We can change the rendering order by rearranging said list.
     *
     * A positive `by` arguments move the node up (it will be rendered on top of
     * the elements it has passed). Negative values move it down.
     *
     * @param by - Number of places by which the node should be moved.
     */
    move(by = 1) {
        const parent = this.parent();
        if (by === 0 || !parent) {
            return this;
        }
        const children = parent.children();
        const newChildren = [];
        if (by > 0) {
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child === this) {
                    const target = i + by;
                    for (; i < target && i + 1 < children.length; i++) {
                        newChildren[i] = children[i + 1];
                    }
                }
                newChildren[i] = child;
            }
        }
        else {
            for (let i = children.length - 1; i >= 0; i--) {
                const child = children[i];
                if (child === this) {
                    const target = i + by;
                    for (; i > target && i > 0; i--) {
                        newChildren[i] = children[i - 1];
                    }
                }
                newChildren[i] = child;
            }
        }
        parent.setParsedChildren(newChildren);
        return this;
    }
    /**
     * Move the node up in relation to its siblings.
     *
     * @remarks
     * The node will exchange places with the sibling right above it (if any) and
     * from then on will be rendered on top of it.
     */
    moveUp() {
        return this.move(1);
    }
    /**
     * Move the node down in relation to its siblings.
     *
     * @remarks
     * The node will exchange places with the sibling right below it (if any) and
     * from then on will be rendered under it.
     */
    moveDown() {
        return this.move(-1);
    }
    /**
     * Move the node to the top in relation to its siblings.
     *
     * @remarks
     * The node will be placed at the end of the children list and from then on
     * will be rendered on top of all of its siblings.
     */
    moveToTop() {
        return this.move(Infinity);
    }
    /**
     * Move the node to the bottom in relation to its siblings.
     *
     * @remarks
     * The node will be placed at the beginning of the children list and from then
     * on will be rendered below all of its siblings.
     */
    moveToBottom() {
        return this.move(-Infinity);
    }
    /**
     * Move the node to the provided position relative to its siblings.
     *
     * @remarks
     * If the node is getting moved to a lower position, it will be placed below
     * the sibling that's currently at the provided index (if any).
     * If the node is getting moved to a higher position, it will be placed above
     * the sibling that's currently at the provided index (if any).
     *
     * @param index - The index to move the node to.
     */
    moveTo(index) {
        const parent = this.parent();
        if (!parent) {
            return this;
        }
        const currentIndex = parent.children().indexOf(this);
        const by = index - currentIndex;
        return this.move(by);
    }
    /**
     * Move the node below the provided node in the parent's layout.
     *
     * @remarks
     * The node will be moved below the provided node and from then on will be
     * rendered below it. By default, if the node is already positioned lower than
     * the sibling node, it will not get moved.
     *
     * @param node - The sibling node below which to move.
     * @param directlyBelow - Whether the node should be positioned directly below
     *                        the sibling. When true, will move the node even if
     *                        it is already positioned below the sibling.
     */
    moveBelow(node, directlyBelow = false) {
        const parent = this.parent();
        if (!parent) {
            return this;
        }
        if (node.parent() !== parent) {
            useLogger().error("Cannot position nodes relative to each other if they don't belong to the same parent.");
            return this;
        }
        const children = parent.children();
        const ownIndex = children.indexOf(this);
        const otherIndex = children.indexOf(node);
        if (!directlyBelow && ownIndex < otherIndex) {
            // Nothing to do if the node is already positioned below the target node.
            // We could move the node so it's directly below the sibling node, but
            // that might suddenly move it on top of other nodes. This is likely
            // not what the user wanted to happen when calling this method.
            return this;
        }
        const by = otherIndex - ownIndex - 1;
        return this.move(by);
    }
    /**
     * Move the node above the provided node in the parent's layout.
     *
     * @remarks
     * The node will be moved above the provided node and from then on will be
     * rendered on top of it. By default, if the node is already positioned
     * higher than the sibling node, it will not get moved.
     *
     * @param node - The sibling node below which to move.
     * @param directlyAbove - Whether the node should be positioned directly above the
     *                        sibling. When true, will move the node even if it is
     *                        already positioned above the sibling.
     */
    moveAbove(node, directlyAbove = false) {
        const parent = this.parent();
        if (!parent) {
            return this;
        }
        if (node.parent() !== parent) {
            useLogger().error("Cannot position nodes relative to each other if they don't belong to the same parent.");
            return this;
        }
        const children = parent.children();
        const ownIndex = children.indexOf(this);
        const otherIndex = children.indexOf(node);
        if (!directlyAbove && ownIndex > otherIndex) {
            // Nothing to do if the node is already positioned above the target node.
            // We could move the node so it's directly above the sibling node, but
            // that might suddenly move it below other nodes. This is likely not what
            // the user wanted to happen when calling this method.
            return this;
        }
        const by = otherIndex - ownIndex + 1;
        return this.move(by);
    }
    /**
     * Change the parent of this node while keeping the absolute transform.
     *
     * @remarks
     * After performing this operation, the node will stay in the same place
     * visually, but its parent will be changed.
     *
     * @param newParent - The new parent of this node.
     */
    reparent(newParent) {
        const position = this.absolutePosition();
        const rotation = this.absoluteRotation();
        const scale = this.absoluteScale();
        newParent.add(this);
        this.absolutePosition(position);
        this.absoluteRotation(rotation);
        this.absoluteScale(scale);
    }
    /**
     * Remove all children of this node.
     */
    removeChildren() {
        for (const oldChild of this.realChildren) {
            oldChild.parent(null);
        }
        this.setParsedChildren([]);
    }
    /**
     * Get the current children of this node.
     *
     * @remarks
     * Unlike {@link children}, this method does not have any side effects.
     * It does not register the `children` signal as a dependency, and it does not
     * spawn any children. It can be used to safely retrieve the current state of
     * the scene graph for debugging purposes.
     */
    peekChildren() {
        return this.realChildren;
    }
    findAll(predicate) {
        const result = [];
        const queue = this.reversedChildren();
        while (queue.length > 0) {
            const node = queue.pop();
            if (predicate(node)) {
                result.push(node);
            }
            const children = node.children();
            for (let i = children.length - 1; i >= 0; i--) {
                queue.push(children[i]);
            }
        }
        return result;
    }
    findFirst(predicate) {
        const queue = this.reversedChildren();
        while (queue.length > 0) {
            const node = queue.pop();
            if (predicate(node)) {
                return node;
            }
            const children = node.children();
            for (let i = children.length - 1; i >= 0; i--) {
                queue.push(children[i]);
            }
        }
        return null;
    }
    findLast(predicate) {
        const search = [];
        const queue = this.reversedChildren();
        while (queue.length > 0) {
            const node = queue.pop();
            search.push(node);
            const children = node.children();
            for (let i = children.length - 1; i >= 0; i--) {
                queue.push(children[i]);
            }
        }
        while (search.length > 0) {
            const node = search.pop();
            if (predicate(node)) {
                return node;
            }
        }
        return null;
    }
    findAncestor(predicate) {
        let parent = this.parent();
        while (parent) {
            if (predicate(parent)) {
                return parent;
            }
            parent = parent.parent();
        }
        return null;
    }
    /**
     * Get the nth children cast to the specified type.
     *
     * @param index - The index of the child to retrieve.
     */
    childAs(index) {
        return this.children()[index] ?? null;
    }
    /**
     * Get the children array cast to the specified type.
     */
    childrenAs() {
        return this.children();
    }
    /**
     * Get the parent cast to the specified type.
     */
    parentAs() {
        return this.parent() ?? null;
    }
    /**
     * Prepare this node to be disposed of.
     *
     * @remarks
     * This method is called automatically when a scene is refreshed. It will
     * be called even if the node is not currently attached to the tree.
     *
     * The goal of this method is to clean any external references to allow the
     * node to be garbage collected.
     */
    dispose() {
        if (!this.unregister) {
            return;
        }
        this.stateStack = [];
        this.unregister();
        this.unregister = null;
        for (const { signal } of this) {
            signal?.context.dispose();
        }
        for (const child of this.realChildren) {
            child.dispose();
        }
    }
    /**
     * Create a copy of this node.
     *
     * @param customProps - Properties to override.
     */
    clone(customProps = {}) {
        const props = { ...customProps };
        if (isReactive(this.children.context.raw())) {
            props.children ?? (props.children = this.children.context.raw());
        }
        else if (this.children().length > 0) {
            props.children ?? (props.children = this.children().map(child => child.clone()));
        }
        for (const { key, meta, signal } of this) {
            if (!meta.cloneable || key in props)
                continue;
            if (meta.compound) {
                for (const [key, property] of meta.compoundEntries) {
                    if (property in props)
                        continue;
                    const component = signal[key];
                    if (!component.context.isInitial()) {
                        props[property] = component.context.raw();
                    }
                }
            }
            else if (!signal.context.isInitial()) {
                props[key] = signal.context.raw();
            }
        }
        return this.instantiate(props);
    }
    /**
     * Create a copy of this node.
     *
     * @remarks
     * Unlike {@link clone}, a snapshot clone calculates any reactive properties
     * at the moment of cloning and passes the raw values to the copy.
     *
     * @param customProps - Properties to override.
     */
    snapshotClone(customProps = {}) {
        const props = {
            ...this.getState(),
            ...customProps,
        };
        if (this.children().length > 0) {
            props.children ?? (props.children = this.children().map(child => child.snapshotClone()));
        }
        return this.instantiate(props);
    }
    /**
     * Create a reactive copy of this node.
     *
     * @remarks
     * A reactive copy has all its properties dynamically updated to match the
     * source node.
     *
     * @param customProps - Properties to override.
     */
    reactiveClone(customProps = {}) {
        const props = { ...customProps };
        if (this.children().length > 0) {
            props.children ?? (props.children = this.children().map(child => child.reactiveClone()));
        }
        for (const { key, meta, signal } of this) {
            if (!meta.cloneable || key in props)
                continue;
            props[key] = () => signal();
        }
        return this.instantiate(props);
    }
    /**
     * Create an instance of this node's class.
     *
     * @param props - Properties to pass to the constructor.
     */
    instantiate(props = {}) {
        return new this.constructor(props);
    }
    /**
     * Set the children without parsing them.
     *
     * @remarks
     * This method assumes that the caller took care of parsing the children and
     * updating the hierarchy.
     *
     * @param value - The children to set.
     */
    setParsedChildren(value) {
        this.children.context.setter(value);
        this.realChildren = value;
    }
    spawnChildren(reactive, children) {
        const parsedChildren = this.parseChildren(children);
        const keep = new Set();
        for (const newChild of parsedChildren) {
            const current = newChild.parent.context.raw();
            if (current && current !== this) {
                current.removeChild(newChild);
            }
            keep.add(newChild.key);
            newChild.parent(this);
        }
        for (const oldChild of this.realChildren) {
            if (!keep.has(oldChild.key)) {
                oldChild.parent(null);
            }
        }
        this.hasSpawnedChildren = reactive;
        this.realChildren = parsedChildren;
    }
    /**
     * Parse any `ComponentChildren` into an array of nodes.
     *
     * @param children - The children to parse.
     */
    parseChildren(children) {
        const result = [];
        const array = Array.isArray(children) ? children : [children];
        for (const child of array) {
            if (child instanceof Node_1) {
                result.push(child);
            }
        }
        return result;
    }
    /**
     * Remove the given child.
     */
    removeChild(child) {
        this.setParsedChildren(this.children().filter(node => node !== child));
    }
    /**
     * Whether this node should be cached or not.
     */
    requiresCache() {
        return (this.cache() ||
            this.opacity() < 1 ||
            this.compositeOperation() !== 'source-over' ||
            this.hasFilters() ||
            this.hasShadow() ||
            this.shaders().length > 0);
    }
    cacheCanvas() {
        const canvas = document.createElement('canvas').getContext('2d');
        if (!canvas) {
            throw new Error('Could not create a cache canvas');
        }
        return canvas;
    }
    /**
     * Get a cache canvas with the contents of this node rendered onto it.
     */
    async cachedCanvas() {
        const context = this.cacheCanvas();
        const cache = this.worldSpaceCacheBBox();
        const matrix = this.localToWorld();
        context.canvas.width = cache.width;
        context.canvas.height = cache.height;
        context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e - cache.x, matrix.f - cache.y);
        await this.draw(context);
        return context;
    }
    /**
     * Get a bounding box for the contents rendered by this node.
     *
     * @remarks
     * The returned bounding box should be in local space.
     */
    getCacheBBox() {
        return new BBox();
    }
    /**
     * Get a bounding box for the contents rendered by this node as well
     * as its children.
     */
    cacheBBox() {
        const cache = this.getCacheBBox();
        const children = this.children();
        const padding = this.cachePadding();
        if (children.length === 0) {
            return cache.addSpacing(padding);
        }
        const points = cache.corners;
        for (const child of children) {
            const childCache = child.fullCacheBBox();
            const childMatrix = child.localToParent();
            points.push(...childCache.corners.map(r => transformVectorAsPoint(r, childMatrix)));
        }
        const bbox = BBox.fromPoints(...points);
        return bbox.addSpacing(padding);
    }
    /**
     * Get a bounding box for the contents rendered by this node (including
     * effects applied after caching).
     *
     * @remarks
     * The returned bounding box should be in local space.
     */
    fullCacheBBox() {
        const matrix = this.compositeToLocal();
        const shadowOffset = transformVector(this.shadowOffset(), matrix);
        const shadowBlur = transformScalar(this.shadowBlur(), matrix);
        const result = this.cacheBBox().expand(this.filters.blur() * 2 + shadowBlur);
        if (shadowOffset.x < 0) {
            result.x += shadowOffset.x;
            result.width -= shadowOffset.x;
        }
        else {
            result.width += shadowOffset.x;
        }
        if (shadowOffset.y < 0) {
            result.y += shadowOffset.y;
            result.height -= shadowOffset.y;
        }
        else {
            result.height += shadowOffset.y;
        }
        return result;
    }
    /**
     * Get a bounding box in world space for the contents rendered by this node as
     * well as its children.
     *
     * @remarks
     * This is the same the bounding box returned by {@link cacheBBox} only
     * transformed to world space.
     */
    worldSpaceCacheBBox() {
        const viewBBox = BBox.fromSizeCentered(this.view().size());
        const canvasBBox = BBox.fromPoints(...viewBBox.transformCorners(this.view().localToWorld()));
        const cacheBBox = BBox.fromPoints(...this.cacheBBox().transformCorners(this.localToWorld())).pixelPerfect.expand(2);
        return canvasBBox.intersection(cacheBBox);
    }
    parentWorldSpaceCacheBBox() {
        return (this.findAncestor(node => node.requiresCache())?.worldSpaceCacheBBox() ??
            new BBox(Vector2.zero, useScene2D().getSize()));
    }
    /**
     * Prepare the given context for drawing a cached node onto it.
     *
     * @remarks
     * This method is called before the contents of the cache canvas are drawn
     * on the screen. It can be used to apply effects to the entire node together
     * with its children, instead of applying them individually.
     * Effects such as transparency, shadows, and filters use this technique.
     *
     * Whether the node is cached is decided by the {@link requiresCache} method.
     *
     * @param context - The context using which the cache will be drawn.
     */
    setupDrawFromCache(context) {
        context.globalCompositeOperation = this.compositeOperation();
        context.globalAlpha *= this.opacity();
        if (this.hasFilters()) {
            context.filter = this.filterString();
        }
        if (this.hasShadow()) {
            const matrix = this.compositeToWorld();
            const offset = transformVector(this.shadowOffset(), matrix);
            const blur = transformScalar(this.shadowBlur(), matrix);
            context.shadowColor = this.shadowColor().serialize();
            context.shadowBlur = blur;
            context.shadowOffsetX = offset.x;
            context.shadowOffsetY = offset.y;
        }
        const matrix = this.worldToLocal();
        context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    }
    renderFromSource(context, source, x, y) {
        this.setupDrawFromCache(context);
        const compositeOverride = this.compositeOverride();
        context.drawImage(source, x, y);
        if (compositeOverride > 0) {
            context.save();
            context.globalAlpha *= compositeOverride;
            context.globalCompositeOperation = 'source-over';
            context.drawImage(source, x, y);
            context.restore();
        }
    }
    shaderCanvas(destination, source) {
        const shaders = this.shaders();
        if (shaders.length === 0) {
            return null;
        }
        const scene = useScene2D();
        const size = scene.getRealSize();
        const parentCacheRect = this.parentWorldSpaceCacheBBox();
        const cameraToWorld = new DOMMatrix()
            .scaleSelf(size.width / parentCacheRect.width, size.height / -parentCacheRect.height)
            .translateSelf(parentCacheRect.x / -size.width, parentCacheRect.y / size.height - 1);
        const cacheRect = this.worldSpaceCacheBBox();
        const cameraToCache = new DOMMatrix()
            .scaleSelf(size.width / cacheRect.width, size.height / -cacheRect.height)
            .translateSelf(cacheRect.x / -size.width, cacheRect.y / size.height - 1)
            .invertSelf();
        const gl = scene.shaders.getGL();
        scene.shaders.copyTextures(destination, source);
        scene.shaders.clear();
        for (const shader of shaders) {
            const program = scene.shaders.getProgram(shader.fragment);
            if (!program) {
                continue;
            }
            if (shader.uniforms) {
                for (const [name, uniform] of Object.entries(shader.uniforms)) {
                    const location = gl.getUniformLocation(program, name);
                    if (location === null) {
                        continue;
                    }
                    const value = unwrap(uniform);
                    if (typeof value === 'number') {
                        gl.uniform1f(location, value);
                    }
                    else if ('toUniform' in value) {
                        value.toUniform(gl, location);
                    }
                    else if (value.length === 1) {
                        gl.uniform1f(location, value[0]);
                    }
                    else if (value.length === 2) {
                        gl.uniform2f(location, value[0], value[1]);
                    }
                    else if (value.length === 3) {
                        gl.uniform3f(location, value[0], value[1], value[2]);
                    }
                    else if (value.length === 4) {
                        gl.uniform4f(location, value[0], value[1], value[2], value[3]);
                    }
                }
            }
            gl.uniform1f(gl.getUniformLocation(program, UNIFORM_TIME), this.view2D.globalTime());
            gl.uniform1i(gl.getUniformLocation(program, UNIFORM_TIME), scene.playback.frame);
            gl.uniformMatrix4fv(gl.getUniformLocation(program, UNIFORM_SOURCE_MATRIX), false, cameraToCache.toFloat32Array());
            gl.uniformMatrix4fv(gl.getUniformLocation(program, UNIFORM_DESTINATION_MATRIX), false, cameraToWorld.toFloat32Array());
            shader.setup?.(gl, program);
            scene.shaders.render();
            shader.teardown?.(gl, program);
        }
        return gl.canvas;
    }
    /**
     * Render this node onto the given canvas.
     *
     * @param context - The context to draw with.
     */
    async render(context) {
        if (this.absoluteOpacity() <= 0) {
            return;
        }
        context.save();
        this.transformContext(context);
        if (this.requiresCache()) {
            const cacheRect = this.worldSpaceCacheBBox();
            if (cacheRect.width !== 0 && cacheRect.height !== 0) {
                const cache = (await this.cachedCanvas()).canvas;
                const source = this.shaderCanvas(context.canvas, cache);
                if (source) {
                    this.renderFromSource(context, source, 0, 0);
                }
                else {
                    this.renderFromSource(context, cache, cacheRect.position.x, cacheRect.position.y);
                }
            }
        }
        else {
            await this.draw(context);
        }
        context.restore();
    }
    /**
     * Draw this node onto the canvas.
     *
     * @remarks
     * This method is used when drawing directly onto the screen as well as onto
     * the cache canvas.
     * It assumes that the context have already been transformed to local space.
     *
     * @param context - The context to draw with.
     */
    async draw(context) {
        await this.drawChildren(context);
    }
    async drawChildren(context) {
        for (const child of this.sortedChildren()) {
            await child.render(context);
        }
    }
    /**
     * Draw an overlay for this node.
     *
     * @remarks
     * The overlay for the currently inspected node is displayed on top of the
     * canvas.
     *
     * The provided context is in screen space. The local-to-screen matrix can be
     * used to transform all shapes that need to be displayed.
     * This approach allows to keep the line widths and gizmo sizes consistent,
     * no matter how zoomed-in the view is.
     *
     * @param context - The context to draw with.
     * @param matrix - A local-to-screen matrix.
     */
    drawOverlay(context, matrix) {
        const box = this.cacheBBox().transformCorners(matrix);
        const cache = this.getCacheBBox().transformCorners(matrix);
        context.strokeStyle = 'white';
        context.lineWidth = 1;
        context.beginPath();
        drawLine(context, box);
        context.closePath();
        context.stroke();
        context.strokeStyle = 'blue';
        context.beginPath();
        drawLine(context, cache);
        context.closePath();
        context.stroke();
    }
    transformContext(context) {
        const matrix = this.localToParent();
        context.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    }
    /**
     * Try to find a node intersecting the given position.
     *
     * @param position - The searched position.
     */
    hit(position) {
        let hit = null;
        const local = transformVectorAsPoint(position, this.localToParent().inverse());
        const children = this.children();
        for (let i = children.length - 1; i >= 0; i--) {
            hit = children[i].hit(local);
            if (hit) {
                break;
            }
        }
        return hit;
    }
    /**
     * Collect all asynchronous resources used by this node.
     */
    collectAsyncResources() {
        for (const child of this.children()) {
            child.collectAsyncResources();
        }
    }
    /**
     * Wait for any asynchronous resources that this node or its children have.
     *
     * @remarks
     * Certain resources like images are always loaded asynchronously.
     * Awaiting this method makes sure that all such resources are done loading
     * before continuing the animation.
     */
    async toPromise() {
        do {
            await DependencyContext.consumePromises();
            this.collectAsyncResources();
        } while (DependencyContext.hasPromises());
        return this;
    }
    /**
     * Return a snapshot of the node's current signal values.
     *
     * @remarks
     * This method will calculate the values of any reactive properties of the
     * node at the time the method is called.
     */
    getState() {
        const state = {};
        for (const { key, meta, signal } of this) {
            if (!meta.cloneable || key in state)
                continue;
            state[key] = signal();
        }
        return state;
    }
    applyState(state, duration, timing = easeInOutCubic) {
        if (duration === undefined) {
            for (const key in state) {
                const signal = this.signalByKey(key);
                if (signal) {
                    signal(state[key]);
                }
            }
        }
        const tasks = [];
        for (const key in state) {
            const signal = this.signalByKey(key);
            if (state[key] !== signal.context.raw()) {
                tasks.push(signal(state[key], duration, timing));
            }
        }
        return all(...tasks);
    }
    /**
     * Push a snapshot of the node's current state onto the node's state stack.
     *
     * @remarks
     * This method can be used together with the {@link restore} method to save a
     * node's current state and later restore it. It is possible to store more
     * than one state by calling `save` method multiple times.
     */
    save() {
        this.stateStack.push(this.getState());
    }
    restore(duration, timing = easeInOutCubic) {
        const state = this.stateStack.pop();
        if (state !== undefined) {
            return this.applyState(state, duration, timing);
        }
    }
    *[Symbol.iterator]() {
        for (const key in this.properties) {
            const meta = this.properties[key];
            const signal = this.signalByKey(key);
            yield { meta, signal, key };
        }
    }
    signalByKey(key) {
        return this[key];
    }
    reversedChildren() {
        const children = this.children();
        const result = [];
        for (let i = children.length - 1; i >= 0; i--) {
            result.push(children[i]);
        }
        return result;
    }
};
__decorate([
    vector2Signal()
], Node.prototype, "position", void 0);
__decorate([
    wrapper(Vector2),
    cloneable(false),
    signal()
], Node.prototype, "absolutePosition", void 0);
__decorate([
    initial(0),
    signal()
], Node.prototype, "rotation", void 0);
__decorate([
    cloneable(false),
    signal()
], Node.prototype, "absoluteRotation", void 0);
__decorate([
    initial(Vector2.one),
    vector2Signal('scale')
], Node.prototype, "scale", void 0);
__decorate([
    initial(Vector2.zero),
    vector2Signal('skew')
], Node.prototype, "skew", void 0);
__decorate([
    wrapper(Vector2),
    cloneable(false),
    signal()
], Node.prototype, "absoluteScale", void 0);
__decorate([
    initial(0),
    signal()
], Node.prototype, "zIndex", void 0);
__decorate([
    initial(false),
    signal()
], Node.prototype, "cache", void 0);
__decorate([
    spacingSignal('cachePadding')
], Node.prototype, "cachePadding", void 0);
__decorate([
    initial(false),
    signal()
], Node.prototype, "composite", void 0);
__decorate([
    initial('source-over'),
    signal()
], Node.prototype, "compositeOperation", void 0);
__decorate([
    threadable()
], Node.prototype, "tweenCompositeOperation", null);
__decorate([
    initial(1),
    parser((value) => clamp(0, 1, value)),
    signal()
], Node.prototype, "opacity", void 0);
__decorate([
    computed()
], Node.prototype, "absoluteOpacity", null);
__decorate([
    filtersSignal()
], Node.prototype, "filters", void 0);
__decorate([
    initial('#0000'),
    colorSignal()
], Node.prototype, "shadowColor", void 0);
__decorate([
    initial(0),
    signal()
], Node.prototype, "shadowBlur", void 0);
__decorate([
    vector2Signal('shadowOffset')
], Node.prototype, "shadowOffset", void 0);
__decorate([
    initial([]),
    parser(parseShader),
    signal()
], Node.prototype, "shaders", void 0);
__decorate([
    computed()
], Node.prototype, "hasFilters", null);
__decorate([
    computed()
], Node.prototype, "hasShadow", null);
__decorate([
    computed()
], Node.prototype, "filterString", null);
__decorate([
    inspectable(false),
    cloneable(false),
    signal()
], Node.prototype, "spawner", void 0);
__decorate([
    inspectable(false),
    cloneable(false),
    signal()
], Node.prototype, "children", void 0);
__decorate([
    computed()
], Node.prototype, "spawnedChildren", null);
__decorate([
    computed()
], Node.prototype, "sortedChildren", null);
__decorate([
    computed()
], Node.prototype, "localToWorld", null);
__decorate([
    computed()
], Node.prototype, "worldToLocal", null);
__decorate([
    computed()
], Node.prototype, "worldToParent", null);
__decorate([
    computed()
], Node.prototype, "localToParent", null);
__decorate([
    computed()
], Node.prototype, "compositeToWorld", null);
__decorate([
    computed()
], Node.prototype, "compositeRoot", null);
__decorate([
    computed()
], Node.prototype, "compositeToLocal", null);
__decorate([
    computed()
], Node.prototype, "cacheCanvas", null);
__decorate([
    computed()
], Node.prototype, "cachedCanvas", null);
__decorate([
    computed()
], Node.prototype, "cacheBBox", null);
__decorate([
    computed()
], Node.prototype, "fullCacheBBox", null);
__decorate([
    computed()
], Node.prototype, "worldSpaceCacheBBox", null);
__decorate([
    computed()
], Node.prototype, "parentWorldSpaceCacheBBox", null);
Node = Node_1 = __decorate([
    nodeName('Node')
], Node);
export { Node };
Node.prototype.isClass = true;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTm9kZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9Ob2RlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFnQkEsT0FBTyxFQUNMLElBQUksRUFDSixpQkFBaUIsRUFDakIsMEJBQTBCLEVBQzFCLHFCQUFxQixFQUNyQixZQUFZLEVBQ1osT0FBTyxFQUNQLEdBQUcsRUFDSCxLQUFLLEVBQ0wsWUFBWSxFQUNaLGNBQWMsRUFDZCxVQUFVLEVBQ1YsTUFBTSxFQUNOLFVBQVUsRUFDVixjQUFjLEVBQ2QsZUFBZSxFQUNmLGVBQWUsRUFDZixzQkFBc0IsRUFDdEIsTUFBTSxFQUNOLFNBQVMsR0FDVixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBRUwsU0FBUyxFQUNULFdBQVcsRUFDWCxRQUFRLEVBQ1IsZUFBZSxFQUNmLE9BQU8sRUFDUCxpQkFBaUIsRUFDakIsV0FBVyxFQUNYLFFBQVEsRUFDUixNQUFNLEVBQ04sTUFBTSxFQUNOLGFBQWEsRUFDYixPQUFPLEdBQ1IsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLDZCQUE2QixDQUFDO0FBQzFELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQU0xRCxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sMEJBQTBCLENBQUM7QUFDckQsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ2hELE9BQU8sRUFBQyxRQUFRLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFtRTNCLElBQU0sSUFBSSxZQUFWLE1BQU0sSUFBSTtJQXdDZixJQUFXLENBQUM7UUFDVixPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBK0IsQ0FBQztJQUN2RCxDQUFDO0lBQ0QsSUFBVyxDQUFDO1FBQ1YsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQStCLENBQUM7SUFDdkQsQ0FBQztJQXVCUyxtQkFB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