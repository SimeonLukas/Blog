import type { SerializedVector2, SignalValue, SimpleSignal } from '@revideo/core';
import type { DesiredLength } from '../partials';
import type { MediaProps } from './Media';
import { Media } from './Media';
export interface VideoProps extends MediaProps {
    /**
     * {@inheritDoc Video.alpha}
     */
    alpha?: SignalValue<number>;
    /**
     * {@inheritDoc Video.smoothing}
     */
    smoothing?: SignalValue<boolean>;
    /**
     * {@inheritDoc Video.decoder}
     */
    decoder?: SignalValue<'web' | 'ffmpeg' | 'slow' | null>;
}
export declare class Video extends Media {
    /**
     * The alpha value of this video.
     *
     * @remarks
     * Unlike opacity, the alpha value affects only the video itself, leaving the
     * fill, stroke, and children intact.
     */
    readonly alpha: SimpleSignal<number, this>;
    /**
     * Whether the video should be smoothed.
     *
     * @remarks
     * When disabled, the video will be scaled using the nearest neighbor
     * interpolation with no smoothing. The resulting video will appear pixelated.
     *
     * @defaultValue true
     */
    readonly smoothing: SimpleSignal<boolean, this>;
    /**
     * Which decoder to use during rendering. The `web` decoder is the fastest
     * but only supports MP4 files. The `ffmpeg` decoder is slower and more resource
     * intensive but supports more formats. The `slow` decoder is the slowest but
     * supports all formats.
     *
     * @defaultValue null
     */
    readonly decoder: SimpleSignal<'web' | 'ffmpeg' | 'slow' | null, this>;
    detectedFileType: 'mp4' | 'webm' | 'hls' | 'mov' | 'unknown';
    private fileTypeWasDetected;
    private static readonly pool;
    private static readonly imageCommunication;
    constructor(props: VideoProps);
    protected desiredSize(): SerializedVector2<DesiredLength>;
    protected mediaElement(): HTMLVideoElement;
    protected seekedMedia(): HTMLVideoElement;
    protected fastSeekedMedia(): HTMLVideoElement;
    private video;
    protected seekedVideo(): HTMLVideoElement;
    protected fastSeekedVideo(): HTMLVideoElement;
    protected lastFrame: ImageBitmap | null;
    protected webcodecSeekedVideo(): Promise<CanvasImageSource>;
    protected ffmpegSeekedVideo(): Promise<ImageBitmap>;
    protected seekFunction(): Promise<CanvasImageSource>;
    protected draw(context: CanvasRenderingContext2D): Promise<void>;
    protected applyFlex(): void;
    remove(): this;
    private handleUnknownFileType;
    private detectFileType;
}
//# sourceMappingURL=Video.d.ts.map