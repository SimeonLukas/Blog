import { MP4FileSink } from './sink';
const MAX_DECODE_QUEUE_SIZE = 30;
export class Segment {
    constructor(uri, file, edits, currentSegment, startTime = 0) {
        this.done = false;
        this.currentFramePastSegmentEndTime = false;
        this.abortController = new AbortController();
        this.responseFinished = false;
        this.framesProcessed = 0;
        this.framesDue = 0;
        this.frameBuffer = [];
        this.encodedChunkQueue = [];
        this.readMore = async () => { };
        this.uri = uri;
        this.file = file;
        this.file.onSamples = this.onSamples.bind(this);
        this.edit = edits[currentSegment];
        this.startTime = startTime;
        // Check how many frames we skipped because of the startTime and add them to the frames processed.
        const framesSkipped = Math.floor(this.startTime * this.edit.fps);
        this.framesProcessed += framesSkipped;
        this.decoder = new VideoDecoder({
            output: this.onFrame.bind(this),
            error(e) {
                console.error(e);
            },
        });
    }
    async start(decoderConfig) {
        // If this is an empty edit, we just need to fill the buffer with empty frames.
        if (this.edit.mediaTime === -1) {
            this.done = true;
            this.responseFinished = true;
            this.decoder.close();
            const segmentDurationInSeconds = this.edit.segmentDuration /
                this.file.getInfo().videoTracks[0].movie_timescale;
            const framesToFill = Math.ceil(segmentDurationInSeconds * this.edit.fps);
            const height = this.file.getInfo().videoTracks[0].track_height;
            const width = this.file.getInfo().videoTracks[0].track_width;
            const bufferSize = height * width * 4;
            const buffer = new ArrayBuffer(bufferSize);
            const uint8Array = new Uint8Array(buffer);
            // Make the frame black
            uint8Array.fill(0);
            this.frameBuffer = Array.from({ length: framesToFill }, () => {
                return new VideoFrame(uint8Array, {
                    timestamp: 0,
                    duration: 1 / this.edit.fps,
                    codedHeight: height,
                    codedWidth: width,
                    format: 'BGRA',
                });
            });
            return;
        }
        this.decoder.configure(decoderConfig);
        const videoTrack = this.file.getInfo().videoTracks[0];
        const trak = this.file.getTrackById(videoTrack.id);
        const mediaTimeInTimescale = this.edit.mediaTime;
        const startTimeInTimescale = this.startTime * videoTrack.timescale;
        const seekTimeInTimescale = mediaTimeInTimescale + startTimeInTimescale;
        const seekTimeInSec = seekTimeInTimescale / videoTrack.timescale;
        const seekInfo = this.file.seekTrack(seekTimeInSec, true, trak);
        this.readMore = await this.startStreamingAtOffset(this.file, this.uri, seekInfo.offset);
    }
    /**
     * Starts streaming the video at the given URI from the given offset.
     * @param file - MP4Box file. Needs to be created and configured before calling this function.
     * @param uri - URI of the video file.
     * @param offset - Offset to start streaming from.
     * @returns - A function to read more data from the response.
     */
    async startStreamingAtOffset(file, uri, offset) {
        return fetch(uri, {
            headers: {
                /* eslint-disable-next-line @typescript-eslint/naming-convention */
                Range: `bytes=${offset}-`,
            },
            signal: this.abortController.signal,
        }).then(async (response) => {
            if (!response.body) {
                throw new Error('Response body is null');
            }
            const reader = response.body.getReader();
            const sink = new MP4FileSink(file, () => { }, offset);
            return async () => {
                return reader.read().then(({ done, value }) => {
                    // Request is done.
                    if (done) {
                        this.responseFinished = true;
                        this.abortController.abort();
                        sink.close();
                        return;
                    }
                    sink.write(value);
                });
            };
        });
    }
    /**
     * Called when samples are available on the MP4 file.
     * Sends chunks to the decoder.
     */
    onSamples(_unused1, _unused2, samples) {
        for (const sample of samples) {
            const chunk = new EncodedVideoChunk({
                type: sample.is_sync ? 'key' : 'delta',
                timestamp: (1e6 * sample.cts) / sample.timescale,
                duration: (1e6 * sample.duration) / sample.timescale,
                data: sample.data,
            });
            this.framesDue++;
            this.encodedChunkQueue.push(chunk);
            const videoTrack = this.file.getInfo().videoTracks[0];
            const trak = this.file.getTrackById(videoTrack.id);
            this.file.releaseSample(trak, sample.number);
        }
    }
    async decodeChunks() {
        while (this.encodedChunkQueue.length > 0 &&
            this.decoder.decodeQueueSize < MAX_DECODE_QUEUE_SIZE) {
            const chunk = this.encodedChunkQueue.shift();
            if (chunk) {
                this.decoder.decode(chunk);
            }
        }
        // When edit is empty, we cannot call decoder.flush() because decoder was already closed
        if (this.done) {
            this.currentFramePastSegmentEndTime = true;
            return;
        }
        if (this.responseFinished && this.encodedChunkQueue.length === 0) {
            await this.flushDecoderWithRetry();
            this.currentFramePastSegmentEndTime = true;
            return;
        }
    }
    async flushDecoderWithRetry(maxRetries = 3, timeoutMs = 2000) {
        for (let attempt = 0; attempt < maxRetries; attempt++) {
            // Sometimes decoder.flush does not resolve even though the queue size is zero
            if (this.decoder.decodeQueueSize === 0) {
                return;
            }
            try {
                await Promise.race([
                    this.decoder.flush(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Flush timeout')), timeoutMs)),
                ]);
            }
            catch (error) {
                if (attempt === maxRetries) {
                    throw error;
                }
            }
        }
    }
    /**
     * Called when the decoder has a frame ready.
     * Pushes the frame to the buffer so it can be consumed.
     */
    async onFrame(frame) {
        this.framesDue--;
        // If the frame comes before the seek time, close it.
        const mediaTimeInSec = this.edit.mediaTime / this.file.getInfo().videoTracks[0].timescale;
        const seekTimeInSec = this.startTime + mediaTimeInSec;
        const frameTimeInSec = frame.timestamp / 1e6;
        if (frameTimeInSec < seekTimeInSec) {
            frame.close();
            return;
        }
        // Check if we are past the segment duration.
        const segmentDurationInSec = this.edit.segmentDuration /
            this.file.getInfo().videoTracks[0].movie_timescale;
        const segmentEndTime = mediaTimeInSec + segmentDurationInSec;
        if (frameTimeInSec > segmentEndTime) {
            frame.close();
            this.done = true;
            await this.decoder.flush();
            return;
        }
        this.frameBuffer.push(frame);
    }
    async populateBuffer() {
        // Fetch more frames if we don't have any.
        while (this.frameBuffer.length === 0 &&
            !this.currentFramePastSegmentEndTime) {
            if (!this.responseFinished) {
                await this.readMore();
            }
            await this.decodeChunks();
            await new Promise(res => setTimeout(res, 0));
        }
        // Wait for decoder if there are frames due.
        if (this.frameBuffer.length === 0 && this.framesDue > 0) {
            let maxIterations = 200;
            while (this.frameBuffer.length === 0) {
                await new Promise(res => setTimeout(res, 10));
                maxIterations--;
                if (this.done) {
                    return;
                }
                if (maxIterations === 0) {
                    return; // TODO: investigate further, shouldn't this be an error?
                }
            }
        }
    }
    async getNextFrame() {
        await this.populateBuffer();
        const frame = this.frameBuffer.shift();
        if (frame) {
            this.framesProcessed++;
        }
        return frame;
    }
    /**
     * Called when we are done with the extractor.
     */
    async close() {
        this.abortController.abort();
        this.frameBuffer.forEach(frame => frame.close());
        try {
            if (this.decoder.state === 'configured') {
                await this.decoder.flush();
                this.decoder.close();
            }
        }
        catch (e) {
            // Ignore
        }
    }
    getFramesProcessed() {
        return this.framesProcessed;
    }
    getStartTime() {
        return this.startTime;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VnbWVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9saWIvdXRpbHMvdmlkZW8vcGFyc2VyL3NlZ21lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLFFBQVEsQ0FBQztBQUduQyxNQUFNLHFCQUFxQixHQUFHLEVBQUUsQ0FBQztBQUVqQyxNQUFNLE9BQU8sT0FBTztJQW9CbEIsWUFDRSxHQUFXLEVBQ1gsSUFBUyxFQUNULEtBQWEsRUFDYixjQUFzQixFQUN0QixZQUFvQixDQUFDO1FBeEJmLFNBQUksR0FBWSxLQUFLLENBQUM7UUFDdEIsbUNBQThCLEdBQVksS0FBSyxDQUFDO1FBQ2hELG9CQUFlLEdBQUcsSUFBSSxlQUFlLEVBQUUsQ0FBQztRQU14QyxxQkFBZ0IsR0FBWSxLQUFLLENBQUM7UUFHbEMsb0JBQWUsR0FBRyxDQUFDLENBQUM7UUFFcEIsY0FBUyxHQUFHLENBQUMsQ0FBQztRQUNkLGdCQUFXLEdBQWlCLEVBQUUsQ0FBQztRQUMvQixzQkFBaUIsR0FBd0IsRUFBRSxDQUFDO1FBRTVDLGFBQVEsR0FBd0IsS0FBSyxJQUFJLEVBQUUsR0FBRSxDQUFDLENBQUM7UUFTckQsSUFBSSxDQUFDLEdBQUcsR0FBRyxHQUFHLENBQUM7UUFFZixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQztRQUNqQixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoRCxJQUFJLENBQUMsSUFBSSxHQUFHLEtBQUssQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUVsQyxJQUFJLENBQUMsU0FBUyxHQUFHLFNBQVMsQ0FBQztRQUUzQixrR0FBa0c7UUFDbEcsTUFBTSxhQUFhLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENB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