import type { Project } from '../app/Project';
import type { AssetInfo, RendererResult, RendererSettings } from '../app/Renderer';
import type { Exporter } from './Exporter';
export interface FfmpegExporterOptions {
    format: 'mp4' | 'webm' | 'proRes';
}
/**
 * FFmpeg video exporter.
 *
 * @remarks
 * Most of the export logic is handled on the server. This class communicates
 * with the FFmpegBridge through a WebSocket connection which lets it invoke
 * methods on the FFmpegExporterServer class.
 *
 * For example, calling the following method:
 * ```ts
 * async this.invoke('process', 7);
 * ```
 * Will invoke the `process` method on the FFmpegExporterServer class with `7`
 * as the argument. The result of the method will be returned as a Promise.
 *
 * Before any methods can be invoked, the FFmpegExporterServer class must be
 * initialized by invoking `start`.
 */
export declare class FFmpegExporterClient implements Exporter {
    static readonly id = "@revideo/core/ffmpeg";
    static readonly displayName = "Video (FFmpeg)";
    private readonly settings;
    private readonly exporterOptions;
    static create(_: Project, settings: RendererSettings): Promise<FFmpegExporterClient>;
    private static readonly response;
    constructor(settings: RendererSettings);
    start(): Promise<void>;
    handleFrame(canvas: HTMLCanvasElement): Promise<void>;
    private blobToDataUrl;
    stop(result: RendererResult): Promise<void>;
    kill(): Promise<void>;
    downloadVideos(assets: AssetInfo[][]): Promise<void>;
    generateAudio(assets: AssetInfo[][], startFrame: number, endFrame: number): Promise<void>;
    mergeMedia(): Promise<void>;
    /**
     * Remotely invoke a method on the server and wait for a response.
     *
     * @param method - The method name to execute on the server.
     * @param data - The data that will be passed as an argument to the method.
     *               Should be serializable.
     */
    private invoke;
}
//# sourceMappingURL=FFmpegExporter.d.ts.map