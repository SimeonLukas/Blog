"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.audioCodecs = void 0;
exports.generateAudio = generateAudio;
exports.mergeMedia = mergeMedia;
const ffmpeg = require("fluent-ffmpeg");
const fs = require("fs");
const os = require("os");
const path = require("path");
const ffmpeg_exporter_server_1 = require("./ffmpeg-exporter-server");
const settings_1 = require("./settings");
const utils_1 = require("./utils");
exports.audioCodecs = {
    mp4: 'aac',
    webm: 'libopus',
    proRes: 'aac',
};
const SAMPLE_RATE = 48000;
function getAssetPlacement(frames) {
    const assets = [];
    // A map to keep track of the first and last currentTime for each asset.
    const assetTimeMap = new Map();
    for (let frame = 0; frame < frames.length; frame++) {
        for (const asset of frames[frame]) {
            if (!assetTimeMap.has(asset.key)) {
                // If the asset is not in the map, add it with its current time as both start and end.
                assetTimeMap.set(asset.key, {
                    start: asset.currentTime,
                    end: asset.currentTime,
                });
                assets.push({
                    key: asset.key,
                    src: asset.src,
                    type: asset.type,
                    startInVideo: frame,
                    endInVideo: frame,
                    duration: 0, // Placeholder, will be recalculated later based on frames
                    durationInSeconds: 0, // Placeholder, will be calculated based on currentTime
                    playbackRate: asset.playbackRate,
                    volume: asset.volume,
                    trimLeftInSeconds: asset.currentTime,
                });
            }
            else {
                // If the asset is already in the map, update the end time.
                const timeInfo = assetTimeMap.get(asset.key);
                if (timeInfo) {
                    timeInfo.end = asset.currentTime;
                    assetTimeMap.set(asset.key, timeInfo);
                }
                const existingAsset = assets.find(a => a.key === asset.key);
                if (existingAsset) {
                    existingAsset.endInVideo = frame;
                }
            }
        }
    }
    // Calculate the duration based on frame count and durationInSeconds based on currentTime.
    assets.forEach(asset => {
        const timeInfo = assetTimeMap.get(asset.key);
        if (timeInfo) {
            // Calculate durationInSeconds based on the start and end currentTime values.
            asset.durationInSeconds =
                (timeInfo.end - timeInfo.start) / asset.playbackRate;
        }
        // Recalculate the original duration based on frame count.
        asset.duration = asset.endInVideo - asset.startInVideo + 1;
    });
    return assets;
}
function calculateAtempoFilters(playbackRate) {
    const atempoFilters = [];
    // Calculate how many times we need to 100x the speed
    let rate = playbackRate;
    while (rate > 100.0) {
        atempoFilters.push('atempo=100.0');
        rate /= 100.0;
    }
    // Add the last atempo filter with the remaining rate
    if (rate > 1.0) {
        atempoFilters.push(`atempo=${rate}`);
    }
    // Calculate how many times we need to halve the speed
    rate = playbackRate;
    while (rate < 0.5) {
        atempoFilters.push('atempo=0.5');
        rate *= 2.0;
    }
    // Add the last atempo filter with the remaining rate
    if (rate < 1.0) {
        atempoFilters.push(`atempo=${rate}`);
    }
    return atempoFilters;
}
async function prepareAudio(outputDir, tempDir, asset, startFrame, endFrame, fps) {
    // Construct the output path
    const sanitizedKey = asset.key.replace(/[/[\]]/g, '-');
    const outputPath = path.join(tempDir, `${sanitizedKey}.wav`);
    const trimLeft = asset.trimLeftInSeconds / asset.playbackRate;
    const trimRight = 1 / fps +
        Math.min(trimLeft + asset.durationInSeconds, trimLeft + (endFrame - startFrame) / fps);
    const padStart = (asset.startInVideo / fps) * 1000;
    const assetSampleRate = await (0, utils_1.getSampleRate)((0, utils_1.resolvePath)(outputDir, asset.src));
    const padEnd = Math.max(0, (assetSampleRate * (endFrame - startFrame + 1)) / fps -
        (assetSampleRate * asset.duration) / fps -
        (assetSampleRate * padStart) / 1000);
    const atempoFilters = calculateAtempoFilters(asset.playbackRate); // atempo filter value must be >=0.5 and <=100. If the value is higher or lower, this function sets multiple atempo filters
    const resolvedPath = (0, utils_1.resolvePath)(outputDir, asset.src);
    await new Promise((resolve, reject) => {
        const audioFilters = [
            ...atempoFilters,
            `atrim=start=${trimLeft}:end=${trimRight}`,
            `apad=pad_len=${padEnd}`,
            `adelay=${padStart}|${padStart}|${padStart}`,
            `volume=${asset.volume}`,
        ].join(',');
        ffmpeg.setFfmpegPath(settings_1.ffmpegSettings.getFfmpegPath());
        ffmpeg(resolvedPath)
            .audioChannels(2)
            .audioCodec('pcm_s16le')
            .audioFrequency(SAMPLE_RATE)
            .outputOptions([`-af`, audioFilters])
            .on('end', () => {
            resolve();
        })
            .on('error', err => {
            console.error(`Error processing audio for asset key: ${asset.key}`, err);
            reject(err);
        })
            .save(outputPath);
    });
    return outputPath;
}
async function mergeAudioTracks(tempDir, audioFilenames) {
    return new Promise((resolve, reject) => {
        ffmpeg.setFfmpegPath(settings_1.ffmpegSettings.getFfmpegPath());
        const command = ffmpeg();
        audioFilenames.forEach(filename => {
            command.input(filename);
        });
        command
            .complexFilter([
            `amix=inputs=${audioFilenames.length}:duration=longest,volume=${audioFilenames.length}`,
        ])
            .outputOptions(['-c:a', 'pcm_s16le'])
            .on('end', () => {
            resolve();
        })
            .on('error', err => {
            console.error(`Error merging audio tracks: ${err.message}`);
            reject(err);
        })
            .save(path.join(tempDir, `audio.wav`));
    });
}
async function generateAudio({ outputDir, tempDir, assets, startFrame, endFrame, fps, }) {
    const fullTempDir = path.join(os.tmpdir(), tempDir);
    await (0, utils_1.makeSureFolderExists)(outputDir);
    await (0, utils_1.makeSureFolderExists)(fullTempDir);
    const assetPositions = getAssetPlacement(assets);
    const audioFilenames = [];
    for (const asset of assetPositions) {
        let hasAudioStream = true;
        if (asset.type !== 'audio') {
            hasAudioStream = await (0, utils_1.checkForAudioStream)((0, utils_1.resolvePath)(outputDir, asset.src));
        }
        if (asset.playbackRate !== 0 && asset.volume !== 0 && hasAudioStream) {
            const filename = await prepareAudio(outputDir, fullTempDir, asset, startFrame, endFrame, fps);
            audioFilenames.push(filename);
        }
    }
    if (audioFilenames.length > 0) {
        await mergeAudioTracks(fullTempDir, audioFilenames);
    }
    return audioFilenames;
}
async function mergeMedia(outputFilename, outputDir, tempDir, format) {
    const fullTempDir = path.join(os.tmpdir(), tempDir);
    await (0, utils_1.makeSureFolderExists)(outputDir);
    await (0, utils_1.makeSureFolderExists)(fullTempDir);
    const audioWavExists = fs.existsSync(path.join(fullTempDir, `audio.wav`));
    if (audioWavExists) {
        await (0, utils_1.mergeAudioWithVideo)(path.join(fullTempDir, `audio.wav`), path.join(fullTempDir, `visuals.${ffmpeg_exporter_server_1.extensions[format]}`), path.join(outputDir, `${outputFilename}.${ffmpeg_exporter_server_1.extensions[format]}`), exports.audioCodecs[format]);
    }
    else {
        const destination = path.join(outputDir, `${outputFilename}.${ffmpeg_exporter_server_1.extensions[format]}`);
        await fs.promises.copyFile(path.join(fullTempDir, `visuals.${ffmpeg_exporter_server_1.extensions[format]}`), destination);
    }
    if (fullTempDir.endsWith('-undefined')) {
        await fs.promises
            .rm(fullTempDir, { recursive: true, force: true })
            .catch(() => { });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdGUtYXVkaW8uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvZ2VuZXJhdGUtYXVkaW8udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBdU5BLHNDQWdEQztBQUVELGdDQWlDQztBQXpTRCx3Q0FBd0M7QUFDeEMseUJBQXlCO0FBQ3pCLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IscUVBQW9EO0FBQ3BELHlDQUEwQztBQUUxQyxtQ0FNaUI7QUFFSixRQUFBLFdBQVcsR0FDdEI7SUFDRSxHQUFHLEVBQUUsS0FBSztJQUNWLElBQUksRUFBRSxTQUFTO0lBQ2YsTUFBTSxFQUFFLEtBQUs7Q0FDZCxDQUFDO0FBZUosTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDO0FBRTFCLFNBQVMsaUJBQWlCLENBQUMsTUFBcUI7SUFDOUMsTUFBTSxNQUFNLEdBQWlCLEVBQUUsQ0FBQztJQUVoQyx3RUFBd0U7SUFDeEUsTUFBTSxZQUFZLEdBQUcsSUFBSSxHQUFHLEVBQXdDLENBQUM7SUFFckUsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsQ0FBQztRQUNuRCxLQUFLLE1BQU0sS0FBSyxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDO1lBQ2xDLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDO2dCQUNqQyxzRkFBc0Y7Z0JBQ3RGLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRTtvQkFDMUIsS0FBSyxFQUFFLEtBQUssQ0FBQyxXQUFXO29CQUN4QixHQUFHLEVBQUUsS0FBSyxDQUFDLFdBQVc7aUJBQ3ZCLENBQUMsQ0FBQztnQkFDSCxNQUFNLENBQUMsSUFBSSxDQUFDO29CQUNWLEdBQUcsRUFBRSxLQUFLLENBQUMsR0FBRztvQkFDZCxHQUFHLEVBQUUsS0FB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